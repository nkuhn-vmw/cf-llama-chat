name: Deploy to Cloud Foundry (Blue-Green)

on:
  # Trigger after successful build on main
  workflow_run:
    workflows: ["Build and Release"]
    types:
      - completed
    branches:
      - main

  # Manual trigger for deployments
  workflow_dispatch:
    inputs:
      skip_nonprod:
        description: 'Skip nonprod deployment (deploy directly to prod)'
        required: false
        type: boolean
        default: false
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - nonprod
          - prod
          - both
        default: both

permissions:
  contents: write

env:
  CF_CLI_VERSION: "8"
  APP_NAME: cf-llama-chat
  HEALTH_CHECK_TIMEOUT: 120

jobs:
  # Build the JAR if triggered manually or get from release
  prepare:
    runs-on: ubuntu-latest
    # Only run if workflow_run was successful OR manual dispatch
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    outputs:
      version: ${{ steps.version.outputs.version }}
      jar_name: ${{ steps.version.outputs.jar_name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      - name: Build JAR
        run: mvn -B clean package -DskipTests

      - name: Get version
        id: version
        run: |
          VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          SHORT_SHA=$(git rev-parse --short HEAD)
          DEPLOY_VERSION="${VERSION}-${SHORT_SHA}"
          echo "version=${DEPLOY_VERSION}" >> $GITHUB_OUTPUT
          echo "jar_name=cf-llama-chat-${VERSION}.jar" >> $GITHUB_OUTPUT
          echo "Deployment version: ${DEPLOY_VERSION}"

      - name: Upload JAR artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: target/*.jar
          retention-days: 1

      - name: Upload manifest
        uses: actions/upload-artifact@v4
        with:
          name: manifest
          path: manifest.yml
          retention-days: 1

  # Deploy to nonprod using blue-green strategy
  deploy-nonprod:
    needs: prepare
    if: |
      needs.prepare.result == 'success' &&
      (github.event_name == 'workflow_run' ||
       (github.event_name == 'workflow_dispatch' &&
        inputs.skip_nonprod != true &&
        inputs.environment != 'prod'))
    runs-on: ubuntu-latest
    environment: nonprod
    outputs:
      old_app: ${{ steps.deploy.outputs.old_app }}
      new_app: ${{ steps.deploy.outputs.new_app }}

    steps:
      - name: Download JAR
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: ./artifacts

      - name: Download manifest
        uses: actions/download-artifact@v4
        with:
          name: manifest
          path: ./

      - name: Install CF CLI
        run: |
          wget -q "https://packages.cloudfoundry.org/stable?release=linux64-binary&version=v${{ env.CF_CLI_VERSION }}&source=github" -O cf-cli.tgz
          tar -xzf cf-cli.tgz
          sudo mv cf8 /usr/local/bin/cf
          cf version

      - name: Login to Cloud Foundry (Nonprod)
        run: |
          cf api "${{ secrets.CF_API_NONPROD }}"
          cf auth "${{ secrets.CF_USERNAME_NONPROD }}" "${{ secrets.CF_PASSWORD_NONPROD }}"
          cf target -o "${{ secrets.CF_ORG_NONPROD }}" -s "${{ secrets.CF_SPACE_NONPROD }}"

      - name: Blue-Green Deploy
        id: deploy
        env:
          APP_ROUTE: ${{ secrets.APP_ROUTE_NONPROD }}
          CF_DOMAIN: ${{ secrets.CF_DOMAIN_NONPROD }}
          DEPLOY_VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          set -e

          GREEN_APP="${{ env.APP_NAME }}-green"
          BLUE_APP="${{ env.APP_NAME }}"

          echo "Starting blue-green deployment..."
          echo "Green (new): ${GREEN_APP}"
          echo "Blue (current): ${BLUE_APP}"

          # Check if blue app exists
          BLUE_EXISTS=$(cf apps | grep -c "^${BLUE_APP} " || echo "0")

          # Find JAR file
          JAR_FILE=$(find ./artifacts -name "*.jar" -type f | head -1)
          echo "Deploying JAR: ${JAR_FILE}"

          # Deploy green (new version) without route
          echo "Deploying green instance..."
          cf push "${GREEN_APP}" \
            -f manifest.yml \
            -p "${JAR_FILE}" \
            --no-route \
            --no-start

          # Set environment variables
          cf set-env "${GREEN_APP}" SPRING_PROFILES_ACTIVE "cloud"
          cf set-env "${GREEN_APP}" APP_VERSION "${DEPLOY_VERSION}"

          # Start the green app
          cf start "${GREEN_APP}"

          # Wait for green app to be healthy
          echo "Waiting for green app to be healthy..."
          ATTEMPTS=0
          MAX_ATTEMPTS=30
          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            STATUS=$(cf app "${GREEN_APP}" | grep -E "^#0" | awk '{print $2}' || echo "unknown")
            if [ "$STATUS" = "running" ]; then
              echo "Green app is healthy!"
              break
            fi
            echo "Waiting for app to start... (attempt $((ATTEMPTS+1))/${MAX_ATTEMPTS})"
            sleep 10
            ATTEMPTS=$((ATTEMPTS+1))
          done

          if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
            echo "Green app failed to become healthy"
            cf logs "${GREEN_APP}" --recent
            cf delete "${GREEN_APP}" -f
            exit 1
          fi

          # Map route to green app
          echo "Mapping route to green app..."
          cf map-route "${GREEN_APP}" "${CF_DOMAIN}" --hostname "${APP_ROUTE}"

          # If blue exists, unmap route and stop it
          if [ "$BLUE_EXISTS" -gt 0 ]; then
            echo "Unmapping route from blue app..."
            cf unmap-route "${BLUE_APP}" "${CF_DOMAIN}" --hostname "${APP_ROUTE}" || true

            echo "Stopping blue app..."
            cf stop "${BLUE_APP}" || true

            # Rename blue to old for cleanup
            cf rename "${BLUE_APP}" "${BLUE_APP}-old" || true
            echo "old_app=${BLUE_APP}-old" >> $GITHUB_OUTPUT
          fi

          # Rename green to blue (becomes the new production)
          echo "Promoting green to blue..."
          cf rename "${GREEN_APP}" "${BLUE_APP}"

          echo "new_app=${BLUE_APP}" >> $GITHUB_OUTPUT
          echo "Blue-green deployment to nonprod complete!"

      - name: Deployment Summary
        run: |
          echo "## Nonprod Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.prepare.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**App:** ${{ env.APP_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Route:** https://${{ secrets.APP_ROUTE_NONPROD }}.${{ secrets.CF_DOMAIN_NONPROD }}" >> $GITHUB_STEP_SUMMARY

  # Deploy to production using blue-green strategy
  deploy-prod:
    needs: [prepare, deploy-nonprod]
    if: |
      always() &&
      needs.prepare.result == 'success' &&
      (needs.deploy-nonprod.result == 'success' || needs.deploy-nonprod.result == 'skipped') &&
      (github.event_name == 'workflow_run' ||
       (github.event_name == 'workflow_dispatch' && inputs.environment != 'nonprod'))
    runs-on: ubuntu-latest
    environment: production
    outputs:
      old_app: ${{ steps.deploy.outputs.old_app }}
      new_app: ${{ steps.deploy.outputs.new_app }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download JAR
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: ./artifacts

      - name: Download manifest
        uses: actions/download-artifact@v4
        with:
          name: manifest
          path: ./

      - name: Install CF CLI
        run: |
          wget -q "https://packages.cloudfoundry.org/stable?release=linux64-binary&version=v${{ env.CF_CLI_VERSION }}&source=github" -O cf-cli.tgz
          tar -xzf cf-cli.tgz
          sudo mv cf8 /usr/local/bin/cf
          cf version

      - name: Login to Cloud Foundry (Prod)
        run: |
          cf api "${{ secrets.CF_API_PROD }}"
          cf auth "${{ secrets.CF_USERNAME_PROD }}" "${{ secrets.CF_PASSWORD_PROD }}"
          cf target -o "${{ secrets.CF_ORG_PROD }}" -s "${{ secrets.CF_SPACE_PROD }}"

      - name: Blue-Green Deploy
        id: deploy
        env:
          APP_ROUTE: ${{ secrets.APP_ROUTE_PROD }}
          CF_DOMAIN: ${{ secrets.CF_DOMAIN_PROD }}
          DEPLOY_VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          set -e

          GREEN_APP="${{ env.APP_NAME }}-green"
          BLUE_APP="${{ env.APP_NAME }}"

          echo "Starting blue-green deployment to PRODUCTION..."
          echo "Green (new): ${GREEN_APP}"
          echo "Blue (current): ${BLUE_APP}"

          # Check if blue app exists
          BLUE_EXISTS=$(cf apps | grep -c "^${BLUE_APP} " || echo "0")

          # Find JAR file
          JAR_FILE=$(find ./artifacts -name "*.jar" -type f | head -1)
          echo "Deploying JAR: ${JAR_FILE}"

          # Deploy green (new version) without route
          echo "Deploying green instance..."
          cf push "${GREEN_APP}" \
            -f manifest.yml \
            -p "${JAR_FILE}" \
            --no-route \
            --no-start

          # Set environment variables
          cf set-env "${GREEN_APP}" SPRING_PROFILES_ACTIVE "cloud"
          cf set-env "${GREEN_APP}" APP_VERSION "${DEPLOY_VERSION}"

          # Start the green app
          cf start "${GREEN_APP}"

          # Wait for green app to be healthy
          echo "Waiting for green app to be healthy..."
          ATTEMPTS=0
          MAX_ATTEMPTS=30
          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            STATUS=$(cf app "${GREEN_APP}" | grep -E "^#0" | awk '{print $2}' || echo "unknown")
            if [ "$STATUS" = "running" ]; then
              echo "Green app is healthy!"
              break
            fi
            echo "Waiting for app to start... (attempt $((ATTEMPTS+1))/${MAX_ATTEMPTS})"
            sleep 10
            ATTEMPTS=$((ATTEMPTS+1))
          done

          if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
            echo "Green app failed to become healthy"
            cf logs "${GREEN_APP}" --recent
            cf delete "${GREEN_APP}" -f
            exit 1
          fi

          # Map route to green app
          echo "Mapping route to green app..."
          cf map-route "${GREEN_APP}" "${CF_DOMAIN}" --hostname "${APP_ROUTE}"

          # If blue exists, unmap route and stop it
          if [ "$BLUE_EXISTS" -gt 0 ]; then
            echo "Unmapping route from blue app..."
            cf unmap-route "${BLUE_APP}" "${CF_DOMAIN}" --hostname "${APP_ROUTE}" || true

            echo "Stopping blue app..."
            cf stop "${BLUE_APP}" || true

            # Rename blue to old for cleanup
            cf rename "${BLUE_APP}" "${BLUE_APP}-old" || true
            echo "old_app=${BLUE_APP}-old" >> $GITHUB_OUTPUT
          fi

          # Rename green to blue (becomes the new production)
          echo "Promoting green to blue..."
          cf rename "${GREEN_APP}" "${BLUE_APP}"

          echo "new_app=${BLUE_APP}" >> $GITHUB_OUTPUT
          echo "Blue-green deployment to production complete!"

      - name: Record deployed version
        run: |
          echo "${{ needs.prepare.outputs.version }}" > .last-deployed-version
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .last-deployed-version
          git diff --cached --quiet || git commit -m "Record deployment of ${{ needs.prepare.outputs.version }}"
          git push || echo "Could not push version record"

      - name: Deployment Summary
        run: |
          echo "## Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.prepare.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**App:** ${{ env.APP_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Route:** https://${{ secrets.APP_ROUTE_PROD }}.${{ secrets.CF_DOMAIN_PROD }}" >> $GITHUB_STEP_SUMMARY

  # Cleanup old app instances
  cleanup:
    needs: [deploy-nonprod, deploy-prod]
    if: |
      always() &&
      (needs.deploy-nonprod.result == 'success' || needs.deploy-prod.result == 'success')
    runs-on: ubuntu-latest

    steps:
      - name: Install CF CLI
        run: |
          wget -q "https://packages.cloudfoundry.org/stable?release=linux64-binary&version=v${{ env.CF_CLI_VERSION }}&source=github" -O cf-cli.tgz
          tar -xzf cf-cli.tgz
          sudo mv cf8 /usr/local/bin/cf
          cf version

      - name: Cleanup nonprod old apps
        if: needs.deploy-nonprod.outputs.old_app != ''
        continue-on-error: true
        run: |
          cf api "${{ secrets.CF_API_NONPROD }}"
          cf auth "${{ secrets.CF_USERNAME_NONPROD }}" "${{ secrets.CF_PASSWORD_NONPROD }}"
          cf target -o "${{ secrets.CF_ORG_NONPROD }}" -s "${{ secrets.CF_SPACE_NONPROD }}"

          OLD_APP="${{ needs.deploy-nonprod.outputs.old_app }}"
          if [ -n "$OLD_APP" ]; then
            echo "Deleting old nonprod app: ${OLD_APP}"
            cf delete "${OLD_APP}" -f || true
          fi

      - name: Cleanup prod old apps
        if: needs.deploy-prod.outputs.old_app != ''
        continue-on-error: true
        run: |
          cf api "${{ secrets.CF_API_PROD }}"
          cf auth "${{ secrets.CF_USERNAME_PROD }}" "${{ secrets.CF_PASSWORD_PROD }}"
          cf target -o "${{ secrets.CF_ORG_PROD }}" -s "${{ secrets.CF_SPACE_PROD }}"

          OLD_APP="${{ needs.deploy-prod.outputs.old_app }}"
          if [ -n "$OLD_APP" ]; then
            echo "Deleting old prod app: ${OLD_APP}"
            cf delete "${OLD_APP}" -f || true
          fi

      - name: Cleanup Summary
        run: |
          echo "## Cleanup Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Old application instances have been removed." >> $GITHUB_STEP_SUMMARY
